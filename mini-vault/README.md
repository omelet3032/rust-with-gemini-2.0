공식 문서의 API 시그니처를 읽는 능력은 Rust 중급자로 가는 가장 큰 관문입니다. `Vec::drain`의 시그니처가 복잡해 보이는 이유는 **제네릭(T)**, **수명(&'_)**, **트레이트 바운드(RangeBounds)**, 그리고 **메모리 할당자(A)**가 한데 뒤섞여 있기 때문이죠.

이런 구조를 파악하는 가장 좋은 연습은, **"표준 라이브러리와 비슷한 기능을 하는 미니 구조체를 직접 설계해보는 것"**입니다.

사용자님을 위해 **"제네릭과 트레이트 바운드가 섞인 API 설계 연습 문제"**를 준비했습니다. 라이브러리 제작자가 되었다고 생각하고 주석의 요구사항에 맞춰 시그니처를 완성해 보세요.

---

## 🏋️ 연습 문제: 미니 보관함(Vault) 설계하기

여러 가지 타입(`T`)을 담을 수 있고, 특정 조건으로 아이템을 추출하는 `Vault` 구조체의 메서드를 설계해 봅시다.

### 1단계: 시그니처 완성하기 (빈칸 채우기)

아래 코드의 `____` 부분을 채워보세요.

Rust

`use std::ops::RangeBounds;

struct Vault<T> {
    items: Vec<T>,
}

impl<T> Vault<T> {
    /// 문제: 특정 범위(range)의 아이템들을 뽑아내는(drain) 메서드의 시그니처를 만드세요.
    /// 조건 1: 메서드 이름은 `extract`입니다.
    /// 조건 2: self를 가변으로 빌려야 합니다.
    /// 조건 3: 범위는 `RangeBounds<usize>`를 구현한 제네릭 타입 `R`을 받습니다.
    /// 조건 4: 반환값은 뽑아낸 아이템들의 반복자(Iterator)여야 합니다. 
    /// (여기서는 간단히 Vec의 Drain을 그대로 활용한다고 가정합니다.)
    
    pub fn extract<R>(&mut self, range: R) -> std::vec::Drain<'_, T>
    where
        R: RangeBounds<usize>, 
    {
        self.items.drain(range)
    }
}`

---

## 🧩 2단계: 더 복잡한 제네릭 도전 (직접 작성)

이제 주석만 보고 아래 `Transformer` 구조체의 메서드 시그니처를 직접 작성해 보세요.

Rust

`struct Transformer<T> {
    data: Vec<T>,
}

impl<T> Transformer<T> {
    /// [ 연습 미션 ]
    /// 1. 메서드 이름: `process_and_report`
    /// 2. 제네릭 타입 파라미터: 
    ///    - `U`: 변환 결과의 타입
    ///    - `F`: 변환 로직을 담은 클로저 타입
    /// 3. 매개변수:
    ///    - `self`: 소유권을 가져와서 소비합니다. (into_iter 느낌)
    ///    - `f`: `T`를 받아서 `U`를 반환하는 함수(Fn)입니다.
    /// 4. 반환값: 
    ///    - 변환된 아이템들(`U`)을 담은 새로운 `Vec<U>`를 반환합니다.
    /// 5. 제약 조건(where):
    ///    - `F`는 `Fn(T) -> U` 트레이트를 만족해야 합니다.
    
    // 여기에 코드를 작성해 보세요!
    pub fn process_and_report... 
}`

---

## 💡 공식 문서 읽는 팁 (해석 가이드)

사용자님이 가져오신 `pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>`를 쪼개보면 이렇습니다:

1. **`<R>`**: 이 메서드는 `R`이라는 제네릭 타입을 새로 씁니다.
2. **`(&mut self, range: R)`**: 나를 고칠 수 있게 빌려주고(`&mut self`), 범위(`R`)도 받습니다.
3. **`> Drain<'_, T, A>`**: `Drain`이라는 결과물을 돌려주는데,
    - `'_`: "내가 `self`를 빌리고 있는 동안만 이 결과물도 유효해"라는 **익명 수명**입니다.
    - `T, A`: 원래 `Vec`이 가지고 있던 타입과 할당자 정보를 그대로 들고 갑니다.
4. **`where R: RangeBounds<usize>`**: 아무 `R`이나 안 되고, `0..5`나 `..10` 같은 **범위 표현식**만 허용한다는 뜻입니다.

---

**2단계 문제를 한 번 작성해 보시겠어요?** 제네릭(`U`, `F`)과 트레이트 바운드(`where`)를 적재적소에 배치하는 것이 핵심입니다. 작성하신 후에 저에게 보여주시면 제가 공식 문서 스타일로 꼼꼼히 피드백 드릴게요!

이 연습이 끝나면 실제 `drain`을 내부적으로 어떻게 구현하는지(unsafe 없이)에 대해서도 다뤄볼 수 있습니다. 어떤가요? 이 방식이 도움이 되시나요?